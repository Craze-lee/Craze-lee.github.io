<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【MySQL 原理】01 体系结构]]></title>
    <url>%2F2019%2F03%2F07%2FMySQL%2FMySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[MySQL体系结构–摘自MySQL官方手册 整体可分四层第一层：连接层防止资源的频繁分配、释放，提前建立一个连接池 功能：进行身份验证、线程管理、连接限制、内存检查、数据缓存。 实现：预先在连接池中放入一定数量的连接，当需要建立数据库连接时，从池中取出一个，用完放回去。 通信协议： TCP/IP协议，本地与远程连接 UNIX套接字文件 共享内存 命名管道 第二次：SQL层总共由5个部分组成 1. 管理服务和工具组件备份、复制、集群、管理、配置、迁移等管理工具 2. SQL接口组件进行DML、DDL，存储过程、视图等操作和管理 3. 解析器组件验证和解析SQL命令 4. 查询优化器对SQL查询进行优化 5. 缓存和缓冲区对结果集进行缓存，提升重复查询效率 第三层：插件式存储引擎MySQL的存储引擎是插件式的，能由第三方开发 – 查看数据库支持的引擎 3.1 MyISAM查询速度快，较好的索引优化和数据压缩技术，不支持事务、表锁设计，支持全文索引 MyISAM表由MYD和MYI组成，MYD存放数据数据，MYI存放索引文件 3.2 InnoDB支持事务，行锁设计、支持外键。 每个innodb存储引擎的表单独存放在独立的ibd文件中 3.3 Memory适合存储临时数据，如果数据库重启或崩溃，数据将消失。只支持表锁，并发性能差。 其他还有 Archive 、 Federated 、Maria存储引擎等 第四次：物理文件 支持的文件类型 EXT3、EXT4、NTFS、NFS 文件内容 数据文件 日志文件]]></content>
      <categories>
        <category>MySQL</category>
        <category>原理分析</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>原理分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Golang零基础入门】02 类型与变量]]></title>
    <url>%2F2019%2F03%2F06%2FGolang%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%2F02%20%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>Golang</category>
        <category>零基础入门</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>Golang零基础入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Golang零基础入门】01 Hello，Go]]></title>
    <url>%2F2019%2F03%2F06%2FGolang%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%2F01%20Hello%2C%20GO%2F</url>
    <content type="text"><![CDATA[一、第一个Go程序：hello.go1234567package mainimport "fmt"func main()&#123; fmt.Println("Hello, Go")&#125; 二、go run 一次性调试12$ go run hello.goHello, Go 说明： Go是一门编译型语言，Go语言的工具链将源代码及其依赖转换成计算机的机器指令。 go run 编译一个或多个以.go结尾的源文件，链接库文件，并运行最终生成的可执行文件。 三、go build 直接生成可执行程序如果不只是一次的调试，你可以编译这个程序，保存编译结果以备将来之用。可以用build子命令，将直接生成可执行文件 hello，之后直接运行hello可执行文件，结果与go run时是一致的： 123$ go build hello.go$ ./helloHello, GO 四、一些知识点 Go语言通过包（package）组织，类似其他语言的库、模块、命名空间。每个源文件都以一条 package 声明语句开始，这个例子里就是 package main main 包比较特殊。它定义了一个独立可执行的程序，而不是一个库。在 main 里的 main 函数也很特殊，它是整个程序执行时的入口 使用（import）来导入别的包，import &quot;fmt&quot; gofmt 工具把代码格式化为标准格式，最好在每次提交Git前执行一次，保证代码风格一致 go clean 移除当前源码包里编译生成的文件，如test.out 按照惯例，最好每个包的包声明前添加注释 12// package for app's configpackage config 空标识符（_下划线）类似垃圾箱，将不需要的变量丢弃，如下，只需要range的value，不需要索引 123for _, arg := range args &#123; // todo&#125;]]></content>
      <categories>
        <category>Golang</category>
        <category>零基础入门</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>Golang零基础入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Zookeeper 配置中心实现（Golang）]]></title>
    <url>%2F2019%2F03%2F02%2FZookeeper%2FZookeeper%20%E9%85%8D%E5%90%88Golang%E5%AE%9E%E7%8E%B0%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%2F</url>
    <content type="text"><![CDATA[目标一个乞丐版自更新配置中心，更新配置后，能在各个服务器实现更新 架构 角色 config-web: 配置后台，主要用于管理配置，增改配置 config-agent: 监听配置，遇到变动后，自动拉取最新文件到本地 config-sdk: 业务集成该sdk，用于读取配置 config-web 配置后台 持久存储为MySQL，也可以加一层缓存Redis，设置一个唯一的业务KEY，对应的ZK里的ZNode 对于配置节点的操作，最终必须落盘，持久化存储于MySQL 持久存储成功后，将配置的内容写入ZK集群中 以下是create节点的代码，set的同，这是简单的操作 123456789101112131415161718192021222324package mainimport ( &quot;fmt&quot; . &quot;go-zk/connect&quot; &quot;github.com/samuel/go-zookeeper/zk&quot;)func main() &#123; conn := Connect() defer conn.Close() flags := int32(zk.FlagSequence) acl := zk.WorldACL(zk.PermAll) // create node path := PathConfig.ZNodePath +&quot;/&quot;+ &quot;huodong-&quot; data := []byte(`&#123;&quot;num&quot;:6.13,&quot;strs&quot;:[&quot;a&quot;,&quot;b&quot;]&#125;`) createPath, err := conn.Create(path, data, flags, acl) if err != nil &#123; panic(err) &#125;&#125; config-agent 监控 由于ZK的特性，能保持集群的一致性，以及提供了监听机制，在节点内容被改变时能提供回调 在config-agent监听对应的业务节点 监听的变动时，会有通知，例如，更改节点内容时，获取节点的内容，然后进行落盘，或者存到内存中都 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129package mainimport ( &quot;fmt&quot; &quot;github.com/samuel/go-zookeeper/zk&quot; . &quot;go-zk/connect&quot; &quot;os&quot; &quot;sync&quot;)type Watch struct &#123;&#125;func (this *Watch)ZkChildrenWatch(c *zk.Conn, path string) &#123; for &#123; v, _, get_ch, err := c.ChildrenW(path) if err != nil &#123; fmt.Println(err) &#125; fmt.Printf(&quot;value of path[%s]=[%s].\n&quot;, path, v) for &#123; select &#123; case ch_event := &lt;-get_ch: &#123; fmt.Printf(&quot;%+v\n&quot;, ch_event) if ch_event.Type == zk.EventNodeCreated &#123; fmt.Printf(&quot;has new node[%d] create\n&quot;, ch_event.Path) &#125; else if ch_event.Type == zk.EventNodeDeleted &#123; fmt.Printf(&quot;has node[%s] detete\n&quot;, ch_event.Path) &#125; else if ch_event.Type == zk.EventNodeDataChanged &#123; this.Callback(c, ch_event.Path) &#125; else if ch_event.Type == zk.EventNodeChildrenChanged &#123; fmt.Printf(&quot;children node change%+v\n&quot;, ch_event.Path) &#125; &#125; &#125; break &#125; &#125;&#125;func (this *Watch)ZkNodeWatch(c *zk.Conn, path string) &#123; for &#123; v, _, get_ch, err := c.GetW(path) if err != nil &#123; fmt.Println(err) &#125; fmt.Printf(&quot;value of path[%s]=[%s].\n&quot;, path, v) for &#123; select &#123; case ch_event := &lt;-get_ch: &#123; if ch_event.Type == zk.EventNodeCreated &#123; fmt.Printf(&quot;has new node[%d] create\n&quot;, ch_event.Path) &#125; else if ch_event.Type == zk.EventNodeDeleted &#123; fmt.Printf(&quot;has node[%s] detete\n&quot;, ch_event.Path) &#125; else if ch_event.Type == zk.EventNodeDataChanged &#123; this.Callback(c, ch_event.Path) &#125; &#125; &#125; break &#125; &#125;&#125;func (this *Watch)Callback(c *zk.Conn, path string) &#123; data, _, err := c.Get(path) if err != nil &#123; fmt.Println(err) &#125; // create file fileName := PathConfig.LocalPath + path + &quot;.json&quot; os.Create(fileName) f, err := os.OpenFile(fileName, os.O_WRONLY|os.O_TRUNC, 0600) defer f.Close() if err != nil &#123; fmt.Println(err.Error()) &#125; else &#123; _,err=f.Write([]byte(data)) fmt.Println(err) return &#125; fmt.Print(&quot;Write File OK !!!&quot;)&#125;func main() &#123; conn := Connect() // 监听所有子节点变化 children, _, err := conn.Children(PathConfig.ZNodePath) if err != nil &#123; panic(err) &#125; fmt.Printf(&quot;%+v\n&quot;, children) w := Watch&#123;&#125; var wg sync.WaitGroup wg.Add(1) go func(path string) &#123; w.ZkChildrenWatch(conn, path) &#125;(PathConfig.ZNodePath) wg.Wait() // 监听节点内容变化 //var wg sync.WaitGroup //wg.Add(len(children)) // //for _, path := range children&#123; // path = PathConfig.ZNodePath + &quot;/&quot; + path // go func(path string) &#123; // defer wg.Done() // log.Print(&quot;Zookeeper Watcher Starting, &quot;, path) // w.ZkNodeWatch(conn, path) // &#125;(path) //&#125; //wg.Wait()&#125; config-sdk 客户端加载配置读取配置的方式很多样，两种思路： 直接读取文件，由业务方直接读取，.json 、 .ini 、 .toml等 sdk可以与config-agent结合，如果读取文件加载配置失败，利用agent，重新主动拉一次文件到本地，实现文件的懒加载 效果展示12345678910111213# This is Zookeeper config file.title = &quot;Zookeeper config file&quot;[zookeeper]servers = [&quot;10.00.85.70:2181&quot;, &quot;10.00.80.191:2181&quot;, &quot;10.00.97.239:2181&quot;]port = 2181session_timeout = 500enabled = true[path]znode_path = &quot;/huodong/conf&quot;local_path = &quot;/tmp/zookeeper&quot; 由于在本地测试，嫌麻烦就没有部署到服务器了，将locah_path分别改成”/tmp/zookeeper”、”/tmp/zookeeper1”、”/tmp/zookeeper2”，起三个进程 连接到zk服务器，修改节点的内容set /huodong/conf/huodong-0000000001 &#39;{&quot;num&quot;:6.13,&quot;strs&quot;:[&quot;a&quot;,&quot;b&quot;]}&#39; 看下本地文件就会生成对应的配置文件]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Zookeeper 集群搭建]]></title>
    <url>%2F2019%2F02%2F28%2FZookeeper%2FZookeeper%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[目标用三台机器搭建一个Zookeeper集群 新增myid文件用于配置当前IP对应的编号。可以查看/conf/zoo.cfg的dataDir路径，在该路径新增myid，内容就只协商对应的编号就行 12$ cat /tmp/zookeeper/myid1 编辑配置文件vi /conf/zoo.cfg 在该配置文件下新增以下内容，每个服务器都需要增加 123server.1=10.99.85.70:2888:3888server.2=10.99.80.191:2888:3888server.3=10.99.97.239:2888:3888 说明：server.A=B:C:D A 是一个数字，就是myid里的那个数字，表示这个是第几号服务器 B 是这个服务器的 ip 地址 C 用来集群成员的信息交换以及与集群中的 Leader 服务器交换信息 D 端口是在leader挂掉时专门用来进行选举Leader所用。 逐一启动服务12345678910111213141516171819$ bin/zkServer.sh start#ip 1$ bin/zkServer.sh statusZooKeeper JMX enabled by defaultUsing config: /zookeeper-3.4.8/bin/../conf/zoo.cfgMode: follower#ip 2$ bin/zkServer.sh statusZooKeeper JMX enabled by defaultUsing config: /zookeeper-3.4.8/bin/../conf/zoo.cfgMode: leader# ip 3$ bin/zkServer.sh statusZooKeeper JMX enabled by defaultUsing config: /zookeeper-3.4.8/bin/../conf/zoo.cfgMode: follower Leader选举情况步骤一：启动服务器1时，投票给自己，服务器1获得了1票，没达到半数 步骤二： 启动服务器2时，投票给自己，服务器2获得1票，没达到半数； 服务器1与2都是1票，重新发起投票； 2的服务器ID大于1，1会重新投票给2，2还是仍然投票给自己 服务器2获得了2票，达到半数，当选Leader]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kafka 入门介绍]]></title>
    <url>%2F2019%2F02%2F27%2FKafka%2FKafka%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"></content>
      <categories>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[下一个最大元素 I]]></title>
    <url>%2F2019%2F02%2F26%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AE%97%2F%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%20I%2F</url>
    <content type="text"><![CDATA[题源LeetCode题目：https://leetcode-cn.com/problems/next-greater-element-i/ 给定两个没有重复元素的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。 nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出-1。 示例 1: 输入: nums1 = [4,1,2], nums2 = [1,3,4,2].输出: [-1,3,-1]解释: 对于num1中的数字4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。 对于num1中的数字1，第二个数组中数字1右边的下一个较大数字是 3。 对于num1中的数字2，第二个数组中没有下一个更大的数字，因此输出 -1。 nums1和nums2中所有元素是唯一的。nums1和nums2 的数组大小都不超过1000。 解法关键词：单调栈 循环遍历较长的数组组成单调递减栈 当栈顶小于当前元素时，出栈，存储到数组或hashmap中 循环较短的数组，查找是否在hashmap中 源码1234567891011121314151617181920212223242526272829303132333435&lt;?phpclass Solution &#123; /** * @param Integer[] $nums1 * @param Integer[] $nums2 * @return Integer[] */ function nextGreaterElement($nums1, $nums2) &#123; $hashMap = []; $stack = []; foreach ($nums2 as $value) &#123; while (!empty($stack) &amp;&amp; end($stack) &lt; $value) &#123; $hashMap[array_pop($stack)]=$value; &#125; array_push($stack, $value); &#125; $res = []; foreach ($nums1 as $value) &#123; if (isset($hashMap[$value])) &#123; $res[] = $hashMap[$value]; &#125; else &#123; $res[] = -1; &#125; &#125; return $res; &#125;&#125;$s = new Solution();$res = $s-&gt;nextGreaterElement([1,3,5,2,4],[6,5,4,3,2,1,7]);var_dump($res);]]></content>
      <categories>
        <category>每日一算</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Zookeeper 面试题]]></title>
    <url>%2F2019%2F02%2F25%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2%2FZookeeper%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[1. Zookeeper的用途，选举的原理是什么？用途 分布式锁 服务注册和发现 利用Znode和Watcher，可以实现分布式服务的注册和发现。最著名的应用就是阿里的分布式RPC框架Dubbo。 共享配置和状态信息 Redis的分布式解决方案Codis（豌豆荚），就利用了Zookeeper来存放数据路由表和 codis-proxy 节点的元信息。同时 codis-config 发起的命令都会通过 ZooKeeper 同步到各个存活的 codis-proxy。 软负载均衡 选举原理 每个 server 发出一个投票： 投票的最基本元素是（SID-服务器id,ZXID-事物id） 接受来自各个服务器的投票 处理投票：优先检查 ZXID(数据越新ZXID越大),ZXID比较大的作为leader，ZXID一样的情况下比较SID 统计投票：这里有个过半的概念，大于集群机器数量的一半，即大于或等于（n/2+1）,我们这里的由三台，大于等于2即为达到“过半”的要求。这里也有引申到为什么 Zookeeper 集群推荐是单数。 2. zookeeper watch机制 客户端 服务端 Main进程 创建ZK客户端，会创建connet网络连接通信线程，listener监听线程 通过connect线程将注册的监听事件发送给Zookeeper服务端 将监听事件添加到注册监听器列表 监听到有数据或路径变化，将消息发送给listener listener线程内部调用process方法 3. Zookeeper 分布式锁]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Zookeeper 入门介绍]]></title>
    <url>%2F2019%2F02%2F25%2FZookeeper%2FZookeeper%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Zookeeper文件系统 + 通知机制 特点 一个领导者(Leader)，多个跟随者(Follower)组成的集群 集群中只要有半数以上节点存活，Zookeeper集群就能正常服务 全局数据一致性，每个server保存一份相同的副本，client无论链接哪个server，得到的数据都是一致的 更新请求顺序执行，来自同一个client的请求按顺序执行 数据更新原子性，一次数据更新要么成功要么失败 实时性，在一定时间范围内，client能读到最新数据 数据结构Zookeeper数据模型的结构与Unix文件系统很类似，整体上可看作是一棵树，每个节点称作一个ZNode。每个ZNode默认能存储1MB数据，每个ZNode都可以通过其路径唯一标识。 应用场景(※) 分布式锁 服务注册和发现 利用Znode和Watcher，可以实现分布式服务的注册和发现。最著名的应用就是阿里的分布式RPC框架Dubbo。 共享配置和状态信息 Redis的分布式解决方案Codis（豌豆荚），就利用了Zookeeper来存放数据路由表和 codis-proxy 节点的元信息。同时 codis-config 发起的命令都会通过 ZooKeeper 同步到各个存活的 codis-proxy。 选举机制(※)半数机制（paxos协议）集群中半数以上机器存活，集群可用，所以Zookeeper适合安装奇数台服务器 内部选举在分布式系统中选主最直接的方法是直接选定集群的一个节点为leader，其它的节点为follower，这样引入的一个问题是如果leader节点挂掉，整个集群就挂掉了。需要有一种算法自动选主，如果leader节点挂掉，则从follower节点中选出一个主节点。 1. 选举阶段 Leader election 最大ZXID也就是节点本地的最新事务编号，包含epoch和计数两部分。epoch是纪元的意思，相当于Raft算法选主时候的term，标识当前leader周期，每次选举一个新的Leader服务器后，会生成一个新的epoch 所有节点处于Looking状态，各自依次发起投票，投票包含自己的服务器ID和最新事务ID（ZXID）。 如果发现别人的ZXID比自己大，也就是数据比自己新，那么就重新发起投票，投票给目前已知最大的ZXID所属节点。 每次投票后，服务器都会统计投票数量，判断是否有某个节点得到半数以上的投票。如果存在这样的节点，该节点将会成为准Leader，状态变为Leading。其他节点的状态变为Following。 2. 发现阶段 Discovery 为了防止某些意外情况，比如因网络原因在上一阶段产生多个Leader的情况。 Leader集思广益，接收所有Follower发来各自的最新epoch值。Leader从中选出最大的epoch，基于此值加1，生成新的epoch分发给各个Follower。 各个Follower收到全新的epoch后，返回ACK给Leader，带上各自最大的ZXID和历史事务日志。Leader选出最大的ZXID，并更新自身历史日志。 3. 同步阶段 Synchronization Leader刚才收集得到的最新历史事务日志，同步给集群中所有的Follower。只有当半数Follower同步成功，这个准Leader才能成为正式的Leader。 节点类型持久persistent：client 和 server 断开连接后，创建的节点不删除短暂ephemeral：client 和 server 断开连接后，创建的节点自己删除 另外分 有序号，无序号。创建有序节点时，会自动将节点名增加序列号 12$ create -s /test/no1 &quot;no1&quot;Created /test/no10000000000 data: ZNode存储的数据信息，每个节点数据最大不超过1MBACL(Access Control List): 记录访问权限，哪些人或哪些IP可访问本节点stat: 各种元数据，比如事务ID、版本号、时间戳、大小等child: 当前节点的子节点 stat czxid- 引起这个 znode 创建的 zxid，创建节点的事务的 zxid ctime - znode 被创建的毫秒数 mzxid - znode 最后更新的 zxid mtime - znode 最后修改的毫秒数 pZxid-znode 最后更新的子节点 zxid cversion - znode 子节点变化号，znode 子节点修改次数 7)dataversion - znode 数据变化号 aclVersion - znode 访问控制列表的变化号 ephemeralOwner- 如果是临时节点，这个是znode拥有者的 session id。如果不是临时节点则是 0。 dataLength- znode 的数据长度 numChildren - znode 子节点数量 监听器原理(※) 客户端 服务端 Main进程 创建ZK客户端，会创建connet网络连接通信线程，listener监听线程 通过connect线程将注册的监听事件发送给Zookeeper服务端 将监听事件添加到注册监听器列表 监听到有数据或路径变化，将消息发送给listener listener线程内部调用process方法 常见监听 子节点增减变化（如下示例） 节点数据变化 写数据流程 客户端发出写入数据请求给任意Follower。 Follower把写入数据请求转发给Leader。 Leader采用二阶段提交方式，先发送Propose广播给Follower。 Follower接到Propose消息，写入日志成功后，返回ACK消息给Leader。 Leader接到半数以上ACK消息，返回成功给客户端，并且广播Commit请求给Follower 命令客户端连接 zkcli -server host:port create [-s] [-e] path data acl 12$ create /test "data"Created /test get path [watch] watch指是否监听 12345678910111213[zk: 10.96.86.22:2181(CONNECTED) 10] get /testdatacZxid = 0x10ctime = Mon Feb 25 16:34:23 CST 2019mZxid = 0x10mtime = Mon Feb 25 16:34:23 CST 2019pZxid = 0x10cversion = 0dataVersion = 0aclVersion = 0ephemeralOwner = 0x0dataLength = 4numChildren = 0 更多stat path [watch]set path data [version]ls path [watch]delquota [-n|-b] pathls2 path [watch]setAcl path aclsetquota -n|-b val pathhistoryredo cmdnoprintwatches on|offdelete path [version]sync pathlistquota pathrmr pathaddauth scheme authquitgetAcl pathcloseconnect host:port 参考https://juejin.im/post/5b037d5c518825426e024473https://www.bilibili.com/video/av32093417/https://blog.csdn.net/u013679744/article/details/79222103《从Paxos到ZooKeeper》经典]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务端面试题集（补充）]]></title>
    <url>%2F2019%2F02%2F25%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2%2F%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[来源声明来源网络 补充上篇 mysql事务隔离级别，脏读 mysql索引 B+数 kafka怎么避免重复消费 kafka怎么保证顺序消费 kafka分区有什么用 消费者宕机了，怎么确认有没收到消息 消费者group订阅了一个topic，当topic接收到消息时，消费者group上的所有消费者能接收到消息吗 thrift协议与http协议的区别 golang垃圾回收算法、PHP垃圾回收算法 rpc与http和thrift关系]]></content>
      <categories>
        <category>每日一面</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务端面试题集]]></title>
    <url>%2F2019%2F02%2F23%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2%2F%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E6%B1%87%E6%80%BB%EF%BC%89%2F</url>
    <content type="text"><![CDATA[来源声明从GitHub找到的java面试题集，涵盖的内容比较全，这里仅摘了通用的部分，与语言无关。 GitHub地址 分布式相关 对分布式事务的理解 如何实现负载均衡，有哪些算法可以实现？ Zookeeper的用途，选举的原理是什么？ 数据的垂直拆分水平拆分。 zookeeper watch机制 redis/zk节点宕机如何处理 分布式集群下如何做到唯一序列号 如何做一个分布式锁 用过哪些MQ，怎么用的，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗 MQ系统的数据如何保证不丢失 列举出你能想到的数据库分库分表策略；分库分表后，如何解决全表查询的问题。 算法&amp;数据结构&amp;设计模式 海量url去重类问题（布隆过滤器） 数组和链表数据结构描述，各自的时间复杂度 二叉树遍历 快速排序 BTree相关的操作 在工作中遇到过哪些设计模式，是如何应用的 hash算法的有哪几种，优缺点，使用场景 什么是一致性hash paxos算法 在装饰器模式和代理模式之间，你如何抉择，请结合自身实际情况聊聊 代码重构的步骤和原因，如果理解重构到模式？ 数据库 MySQL InnoDB存储的文件结构 索引树是如何维护的？ 数据库自增主键可能的问题 MySQL的几种优化 mysql索引为什么使用B+树 数据库锁表的相关处理 索引失效场景 高并发下如何做到安全的修改同一行数据，乐观锁和悲观锁是什么，INNODB的行级锁有哪2种，解释其含义 数据库会死锁吗，举一个死锁的例子，mysql怎么解决死锁 Redis&amp;缓存相关 Redis的并发竞争问题如何解决了解Redis事务的CAS操作吗 缓存机器增删如何对系统影响最小，一致性哈希的实现 Redis持久化的几种方式，优缺点是什么，怎么实现的 Redis的缓存失效策略 缓存穿透的解决办法 redis集群，高可用，原理 mySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据 用Redis和任意语言实现一段恶意登录保护的代码，限制1小时内每用户Id最多只能登录5次 redis的数据淘汰策略 网络相关 http1.0和http1.1有什么区别 http和https有什么区别 TCP/IP协议 TCP三次握手和四次挥手的流程，为什么断开连接要4次,如果握手只有两次，会出现什么 TIME_WAIT和CLOSE_WAIT的区别 说说你知道的几种HTTP响应码 当你用浏览器打开一个链接的时候，计算机做了哪些工作步骤 TCP/IP如何保证可靠性，数据包有哪些数据组成 长连接与短连接 Http请求get和post的区别以及数据包格式 简述tcp建立连接3次握手，和断开连接4次握手的过程；关闭连接时，出现TIMEWAIT过多是由什么原因引起，是出现在主动断开方还是被动断开方。 其他 Linux下IO模型有几种，各自的含义是什么 实际场景问题，海量登录日志如何排序和处理SQL操作，主要是索引和聚合函数的应用 实际场景问题解决，典型的TOP K问题 线上bug处理流程 如何从线上日志发现问题 linux利用哪些命令，查找哪里出了问题（例如io密集任务，cpu过度） 场景问题，有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有10个线程同时调用它，如何做到。 用三个线程按顺序循环打印abc三个字母，比如abcabcabc。 常见的缓存策略有哪些，你们项目中用到了什么缓存系统，如何设计的 设计一个秒杀系统，30分钟没付款就自动关闭交易（并发会很高） 请列出你所了解的性能测试工具 后台系统怎么防止请求重复提交？ 有多个相同的接口，我想客户端同时请求，然后只需要在第一个请求返回结果的时候返回给客户端 PHP相关 php-fpm运行原理]]></content>
      <categories>
        <category>每日一面</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis读书笔记一：简单动态字符串]]></title>
    <url>%2F2019%2F02%2F23%2FRedis%2F%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[简单动态字符串 结构12345678struct sdshdr &#123; // 记录已使用字节的数量 long len; // 记录未使用的字节数量 long free; // 保存字符串 char buf[];&#125;; buf以&#39;\0&#39;为作为字符串结束符，为了能使用C语言本身的库 SDS设计对比C语言字符串的优势： 获取字符串长度的时间复杂度 O(1) 避免缓冲区溢出情况 在拼接扩展字符串时，先检测free是否有足够的容量加载新字符，无则新分配内存 减少修改字符串带来的内存重新分配次数： 空间预分配：在做空间扩展时，不仅会分配必须的内存大小，还会额外分配未使用空间。额外分配规则： 如果分配后，sds-&gt;len大小小于1M，将分配额外空间大小为sds-&gt;len。例如：修改后len大小为13，则会分配free=13，最终buf的字节长度为 13(len)+13(fee)+1(&#39;\0&#39;) = 27; 如果分配后，sds-&gt;len大小 大于 1M，将分配额外空间大小为1M。例如，修改后len大小为30M，则会分配free=1M，最终buf的字节长度为 30M + 1M +1byte 惰性空间释放 避免内存重新分配 为将来可能有的增长操作提供了优化 二进制安全 在C语言中，如果存在&#39;\0&#39;，则会终止取值。二进制的内容可能存在该字符，所以在C语言中是不安全的，但sds是根据len取值 兼容部分 C 字符串函数。]]></content>
      <categories>
        <category>Redis</category>
        <category>《Redis设计与实现》读书笔记</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
</search>
