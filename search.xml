<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Zookeeper 入门介绍]]></title>
    <url>%2F2019%2F02%2F25%2FZookeeper%2FZookeeper%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Zookeeper文件系统 + 通知机制 特点 一个领导者(Leader)，多个跟随者(Follower)组成的集群 集群中只要有半数以上节点存活，Zookeeper集群就能正常服务 全局数据一致性，每个server保存一份相同的副本，client无论链接哪个server，得到的数据都是一致的 更新请求顺序执行，来自同一个client的请求按顺序执行 数据更新原子性，一次数据更新要么成功要么失败 实时性，在一定时间范围内，client能读到最新数据 数据结构Zookeeper数据模型的结构与Unix文件系统很类似，整体上可看作是一棵树，每个节点称作一个ZNode。每个ZNode默认能存储1MB数据，每个ZNode都可以通过其路径唯一标识。 应用场景 分布式锁 服务注册和发现 利用Znode和Watcher，可以实现分布式服务的注册和发现。最著名的应用就是阿里的分布式RPC框架Dubbo。 共享配置和状态信息 Redis的分布式解决方案Codis（豌豆荚），就利用了Zookeeper来存放数据路由表和 codis-proxy 节点的元信息。同时 codis-config 发起的命令都会通过 ZooKeeper 同步到各个存活的 codis-proxy。 选举机制半数机制（paxos协议）集群中半数以上机器存活，集群可用，所以Zookeeper适合安装奇数台服务器 内部选举在分布式系统中选主最直接的方法是直接选定集群的一个节点为leader，其它的节点为follower，这样引入的一个问题是如果leader节点挂掉，整个集群就挂掉了。需要有一种算法自动选主，如果leader节点挂掉，则从follower节点中选出一个主节点。 1. 选举阶段 Leader election 最大ZXID也就是节点本地的最新事务编号，包含epoch和计数两部分。epoch是纪元的意思，相当于Raft算法选主时候的term。 所有节点处于Looking状态，各自依次发起投票，投票包含自己的服务器ID和最新事务ID（ZXID）。 如果发现别人的ZXID比自己大，也就是数据比自己新，那么就重新发起投票，投票给目前已知最大的ZXID所属节点。 每次投票后，服务器都会统计投票数量，判断是否有某个节点得到半数以上的投票。如果存在这样的节点，该节点将会成为准Leader，状态变为Leading。其他节点的状态变为Following。 2. 发现阶段 Discovery 为了防止某些意外情况，比如因网络原因在上一阶段产生多个Leader的情况。 Leader集思广益，接收所有Follower发来各自的最新epoch值。Leader从中选出最大的epoch，基于此值加1，生成新的epoch分发给各个Follower。 各个Follower收到全新的epoch后，返回ACK给Leader，带上各自最大的ZXID和历史事务日志。Leader选出最大的ZXID，并更新自身历史日志。 3. 同步阶段 Synchronization Leader刚才收集得到的最新历史事务日志，同步给集群中所有的Follower。只有当半数Follower同步成功，这个准Leader才能成为正式的Leader。 节点类型持久persistent：client 和 server 断开连接后，创建的节点不删除短暂ephemeral：client 和 server 断开连接后，创建的节点自己删除 另外分 有序号，无序号。创建有序节点时，会自动将节点名增加序列号 12$ create -s /test/no1 &quot;no1&quot;Created /test/no10000000000 data: ZNode存储的数据信息，每个节点数据最大不超过1MBACL(Access Control List): 记录访问权限，哪些人或哪些IP可访问本节点stat: 各种元数据，比如事务ID、版本号、时间戳、大小等child: 当前节点的子节点 stat czxid- 引起这个 znode 创建的 zxid，创建节点的事务的 zxid ctime - znode 被创建的毫秒数 mzxid - znode 最后更新的 zxid mtime - znode 最后修改的毫秒数 pZxid-znode 最后更新的子节点 zxid cversion - znode 子节点变化号，znode 子节点修改次数 7)dataversion - znode 数据变化号 aclVersion - znode 访问控制列表的变化号 ephemeralOwner- 如果是临时节点，这个是znode拥有者的 session id。如果不是临时节点则是 0。 dataLength- znode 的数据长度 numChildren - znode 子节点数量 监听器原理 客户端 服务端 Main进程 创建ZK客户端，会创建connet网络连接通信线程，listener监听线程 通过connect线程将注册的监听事件发送给Zookeeper服务端 将监听事件添加到注册监听器列表 监听到有数据或路径变化，将消息发送给listener listener线程内部调用process方法 常见监听 子节点增减变化（如下示例） 节点数据变化 写数据流程 客户端发出写入数据请求给任意Follower。 Follower把写入数据请求转发给Leader。 Leader采用二阶段提交方式，先发送Propose广播给Follower。 Follower接到Propose消息，写入日志成功后，返回ACK消息给Leader。 Leader接到半数以上ACK消息，返回成功给客户端，并且广播Commit请求给Follower 命令客户端连接 zkcli -server host:port create [-s] [-e] path data acl 12$ create /test "data"Created /test get path [watch] watch指是否监听 12345678910111213[zk: 10.96.86.22:2181(CONNECTED) 10] get /testdatacZxid = 0x10ctime = Mon Feb 25 16:34:23 CST 2019mZxid = 0x10mtime = Mon Feb 25 16:34:23 CST 2019pZxid = 0x10cversion = 0dataVersion = 0aclVersion = 0ephemeralOwner = 0x0dataLength = 4numChildren = 0 更多stat path [watch]set path data [version]ls path [watch]delquota [-n|-b] pathls2 path [watch]setAcl path aclsetquota -n|-b val pathhistoryredo cmdnoprintwatches on|offdelete path [version]sync pathlistquota pathrmr pathaddauth scheme authquitgetAcl pathcloseconnect host:port 参考https://juejin.im/post/5b037d5c518825426e024473https://www.bilibili.com/video/av32093417/]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务端面试题集]]></title>
    <url>%2F2019%2F02%2F23%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2%2F%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E6%B1%87%E6%80%BB%EF%BC%89%2F</url>
    <content type="text"><![CDATA[来源声明从GitHub找到的java面试题集，涵盖的内容比较全，这里仅摘了通用的部分，与语言无关。 GitHub地址 分布式相关 对分布式事务的理解 如何实现负载均衡，有哪些算法可以实现？ Zookeeper的用途，选举的原理是什么？ 数据的垂直拆分水平拆分。 zookeeper原理和适用场景 zookeeper watch机制 redis/zk节点宕机如何处理 分布式集群下如何做到唯一序列号 如何做一个分布式锁 用过哪些MQ，怎么用的，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗 MQ系统的数据如何保证不丢失 列举出你能想到的数据库分库分表策略；分库分表后，如何解决全表查询的问题。 算法&amp;数据结构&amp;设计模式 海量url去重类问题（布隆过滤器） 数组和链表数据结构描述，各自的时间复杂度 二叉树遍历 快速排序 BTree相关的操作 在工作中遇到过哪些设计模式，是如何应用的 hash算法的有哪几种，优缺点，使用场景 什么是一致性hash paxos算法 在装饰器模式和代理模式之间，你如何抉择，请结合自身实际情况聊聊 代码重构的步骤和原因，如果理解重构到模式？ 数据库 MySQL InnoDB存储的文件结构 索引树是如何维护的？ 数据库自增主键可能的问题 MySQL的几种优化 mysql索引为什么使用B+树 数据库锁表的相关处理 索引失效场景 高并发下如何做到安全的修改同一行数据，乐观锁和悲观锁是什么，INNODB的行级锁有哪2种，解释其含义 数据库会死锁吗，举一个死锁的例子，mysql怎么解决死锁 Redis&amp;缓存相关 Redis的并发竞争问题如何解决了解Redis事务的CAS操作吗 缓存机器增删如何对系统影响最小，一致性哈希的实现 Redis持久化的几种方式，优缺点是什么，怎么实现的 Redis的缓存失效策略 缓存穿透的解决办法 redis集群，高可用，原理 mySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据 用Redis和任意语言实现一段恶意登录保护的代码，限制1小时内每用户Id最多只能登录5次 redis的数据淘汰策略 网络相关 http1.0和http1.1有什么区别 http和https有什么区别 TCP/IP协议 TCP三次握手和四次挥手的流程，为什么断开连接要4次,如果握手只有两次，会出现什么 TIME_WAIT和CLOSE_WAIT的区别 说说你知道的几种HTTP响应码 当你用浏览器打开一个链接的时候，计算机做了哪些工作步骤 TCP/IP如何保证可靠性，数据包有哪些数据组成 长连接与短连接 Http请求get和post的区别以及数据包格式 简述tcp建立连接3次握手，和断开连接4次握手的过程；关闭连接时，出现TIMEWAIT过多是由什么原因引起，是出现在主动断开方还是被动断开方。 其他 Linux下IO模型有几种，各自的含义是什么 实际场景问题，海量登录日志如何排序和处理SQL操作，主要是索引和聚合函数的应用 实际场景问题解决，典型的TOP K问题 线上bug处理流程 如何从线上日志发现问题 linux利用哪些命令，查找哪里出了问题（例如io密集任务，cpu过度） 场景问题，有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有10个线程同时调用它，如何做到。 用三个线程按顺序循环打印abc三个字母，比如abcabcabc。 常见的缓存策略有哪些，你们项目中用到了什么缓存系统，如何设计的 设计一个秒杀系统，30分钟没付款就自动关闭交易（并发会很高） 请列出你所了解的性能测试工具 后台系统怎么防止请求重复提交？ 有多个相同的接口，我想客户端同时请求，然后只需要在第一个请求返回结果的时候返回给客户端 PHP相关 php-fpm运行原理]]></content>
      <categories>
        <category>每日一面</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis读书笔记一：简单动态字符串]]></title>
    <url>%2F2019%2F02%2F23%2FRedis%2F%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[简单动态字符串 结构12345678struct sdshdr &#123; // 记录已使用字节的数量 long len; // 记录未使用的字节数量 long free; // 保存字符串 char buf[];&#125;; buf以&#39;\0&#39;为作为字符串结束符，为了能使用C语言本身的库 SDS设计对比C语言字符串的优势： 获取字符串长度的时间复杂度 O(1) 避免缓冲区溢出情况 在拼接扩展字符串时，先检测free是否有足够的容量加载新字符，无则新分配内存 减少修改字符串带来的内存重新分配次数： 空间预分配：在做空间扩展时，不仅会分配必须的内存大小，还会额外分配未使用空间。额外分配规则： 如果分配后，sds-&gt;len大小小于1M，将分配额外空间大小为sds-&gt;len。例如：修改后len大小为13，则会分配free=13，最终buf的字节长度为 13(len)+13(fee)+1(&#39;\0&#39;) = 27; 如果分配后，sds-&gt;len大小 大于 1M，将分配额外空间大小为1M。例如，修改后len大小为30M，则会分配free=1M，最终buf的字节长度为 30M + 1M +1byte 惰性空间释放 避免内存重新分配 为将来可能有的增长操作提供了优化 二进制安全 在C语言中，如果存在&#39;\0&#39;，则会终止取值。二进制的内容可能存在该字符，所以在C语言中是不安全的，但sds是根据len取值 兼容部分 C 字符串函数。]]></content>
      <categories>
        <category>Redis</category>
        <category>《Redis设计与实现》读书笔记</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
</search>
